&pio {
	ir_ldo_active: ir_ldo_active {
		pins_cmd_dat {
		pinmux = <PINMUX_GPIO44__FUNC_GPIO44>;
		output-low;
		};
	};
};

&odm {
	sensor_fb: sensor_fb {
		compatible = "oplus,sensor-feedback";
	};
	consumer_ir_core: consumer_ir_core {
		compatible = "oplus,kookong_ir_core";
		vdd-type = <3>;
		pinctrl-names = "default";
		pinctrl-0 = <&ir_ldo_active>;
		ir-ldo-ctrl = <&pio 44 0x00>;
		status = "okay";
	};
	consumerIr: consumerIr {
		compatible = "oplus,kookong_ir_pwm";
		status = "okay";
		pwm-num = <1>;
		pwm-dma-mask = <64>;
	};
	ssc_interactive: ssc_interactive {
		report_brightness = <1>;
		support_pwm_turbo = <1>;
		support_bri_to_scp = <1>;
		need_to_sync_lcd_rate = <0>;
		report_blank_mode = <1>;
		receive_screenshot_info = <1>;
	};
	low_acc_sensor_freq {
		compatible = "oplus,low_acc_speed";
		low_acc_speed;
	};
	oplus_sensor:oplus_sensor {
		compatible = "oplus,sensor-devinfo";
		als-row-coe = <1000>;
		/* sensor start */
		/*
		enum {
			LIS3DH,
			LSM6DS3,
			BMI160,
			LIS2HH12,
			LSM6DSM,
			BMI2XY,
			LSM6DSO,
			ICM4X6XX,
			ICM4263X,
			ICM4N607,
			BMI22X,
			SC7A20,
			MC34X9,
			BMA4XY,
			STK8329,
			BMI3XY,
		};
		*/
		gsensor_1: gsensor_1 {
			status = "okay";
			sensor_name = <9>;//ICM4N607
			device_name = "icm42607";
			i2c_num = <2>;
			i2c_addr = <0x00>;
			direction = <1>;
			eint_num = <17>;
			acc_cali_range= <300 300 300>;
		};
		gsensor_2: gsensor_2 {
			status = "okay";
			sensor_name = <15>;//BMI3XY
			device_name = "bmi3xy";
			i2c_num = <2>;
			i2c_addr = <0x00>;
			direction = <0>;
			eint_num = <17>;
			acc_cali_range= <300 300 300>;
		};

		/*
		enum {
			AKM09911,
			MMC3530,
			MMC5603,
			MXG4300,
			AKM09918,
		};
		*/
		msensor_1: msensor_1 {
			status = "okay";
			sensor_name = <3>;//MXG4300
			i2c_num = <0>;
			i2c_addr = <0x0C>;
			direction = <1>;
			eint_num = <0>;
			para_num = <2>;
			mag_para_1 {
				match_projects = <25668 25669 25678 25679>;
				soft-mag-parameter = <9878 0 319 1 289 0 581 1 10072 0 207 0 119 0 188 0 11322 0>;
			};
			mag_para_2 {
				match_projects = <25604>;
				soft-mag-parameter = <9632 0 946 0 890 0 1528 0 9547 0 984 1 24 0 119 1 9648 0>;
			};
		};

		/*
		enum {
			TMD2725,
			APSD9922,
			STK3335,
			STK3331,
			STK2232,
			TCS3701,
			STK32600,
			STK33502,
			MN78911,
			TCS3720,
			SIP3515,
			STK3329,
			LTR569,
			SIP3510,
		};
		*/
		proximity_1: proximity_1 {
			status = "okay";
			sensor_name = <9>;//TCS3720
			device_name = "tcs3720";
			i2c_num = <0>;
			i2c_addr = <0x39>;
			direction = <0>;
			eint_num = <19>;
			low_step = <300>;
			high_step = <400>;
			low_limit = <400>;
			high_limit = <500>;
			dirty_low_step = <180>;
			dirty_high_step = <280>;
			ps_dirty_limit = <1800>;
			ps_ir_limit = <500>;
			ps_adjust_min = <0>;
			ps_adjust_max = <850>;
			sampling_count = <5>;
			step_max = <400>;
			step_min = <100>;
			step_div = <2000>;
			anti_shake_delta = <120>;
			dynamic_cali_max = <3000>;
			raw2offset_radio = <1000>;
			offset_max = <16000>;
			offset_range_min = <0>;
			offset_range_max = <65534>;
			force_cali_limit = <0>;
			cali_jitter_limit = <85>;
			cal_offset_margin = <3001>;
			sensor-reg = <0xB1 0x0C 0x82 0xE2>;
			60hz_psd_us = <14200>;
			90hz_psd_us = <10600>;
			120hz_psd_us = <7900>;
			ps_check_num = <3>;
			ps_mid_filter = <0>;
			need_to_sync_lcd_rate = <0>;
		};

		light_1: light_1 {
			status = "okay";
			sensor_name = <9>;//TCS3720
			i2c_num = <0>;
			i2c_addr = <0x39>;
			direction = <0>;
			eint_num = <19>;
			als_ratio = <110>;
			cct_type = <0x02>; //0x01 CCT_NORMAL 0x02 CCT_WISE
			device_name = "tcs3720";
			gold_cct_3k = <6498 3044 1284 10492 1001 1001>;
			gold_cct_6k = <4217 3272 1663 9011 1001 1001>;
			lb_bri_max = <4096>;
			ir_ratio = <10>; // *1000
			als_delay = <390>;
			decision_table_index = <7>;
			available_sensor = <14>;
			gold_cct_factor = <941 946 924 966 1001 1001>;
			high_pwm_cct = <1>;
			als_timer_ms = <100>;
			als_buffer_length = <2>;
		};

		/*
		enum {
			SX933x,
			SX937x,
			AW9610X,
		};
		*/
		sar_1: sar_1 {
			status = "okay";
			sensor_name = <1>; // SX937x
			i2c_num = <0>;
			i2c_addr = <0x2c>;
			direction = <0>;
			eint_num = <24>;
			channel_num = <3>;
			channel_0_min = <3321>;
			channel_0_max = <4597>;
			channel_1_min = <2919>;
			channel_1_max = <4040>;
			channel_2_min = <3539>;
			channel_2_max = <4899>;
			reg_table_num = <4>;
                        sup_move_detect = <1>;
		};
		pick_up: pick_up {
			status = "okay";
			use-proximity = <1>;
		};
		lux_aod: lux_aod {
			status = "okay";
			use-proximity = <1>;
		};
		alsps_arch: alsps_arch {
			status = "okay";
			new-arch-supported = <1>;
		};
		cali_arch: cali_arch {
			status = "okay";
			new-arch-supported = <1>;
		};
		oplus_fusion: oplus_fusion {
			status = "okay";
			set_mag_10ms = <0>;
			fusion_style = <2>; // 0:vendor fusion; 1:oppo fusion; 2:mix fusion
		};
		palm_detect: palm_detect{
			status = "okay";
			is_available = <1>;
			fold_type = <2>;
			prox_type = <0>;
			x_limit = <1>;
			y_limit = <6>;
			z_limit = <6>;
			delta_ms_limit = <5000>;
			delta_ms_low = <200>;
			x_gyro_limit = <300000>;
			y_gyro_limit = <300000>;
			z_gyro_limit = <300000>;
			move_limit = <8>;
			als_limit = <3>;
		};
		pocket: pocket {
			status = "okay";
			support_pocket = <1>;
			use_sub_accgyro = <0>;
			need_als = <0>;
		};
		chop: chop {
			status = "okay";
			is_available = <1>;
			is_sup_chop = <1>;
			use-proximity = <1>;

			acc_static_length = <100>;
			acc_move_threshold = <600>;
			acc_move_length = <3>;
			ax_max = <20>;
			ax_min = <20>;
			ax_delta = <70>;
			ax_peek_cnt = <1>;
			ax_extra_cnt = <2>;
			chop_cnt = <2>;
			chop_between_ms = <250>;
			chop_timeout_ms = <700>;
			chop_buffer_size = <10>;
		};
	};
/* sensor end */
};

